<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v13.0.0: ECC key handling functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v13.0.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<!--<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>-->
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s132","s140","s212","s332"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nrf__crypto__keys.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ECC key handling functions.<div class="ingroups"><a class="el" href="group__nrf__crypto.html">Cryptography library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides functions to allocate, free, generate and convert ECC key types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabfd3de82436391e1873d084c36416c04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gabfd3de82436391e1873d084c36416c04">NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE</a>(type)&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE_, type))</td></tr>
<tr class="memdesc:gabfd3de82436391e1873d084c36416c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to calculate size required to hold a ECC private key given curve type(domain), according to the used nrf_crypto backend.  <a href="#gabfd3de82436391e1873d084c36416c04">More...</a><br/></td></tr>
<tr class="separator:gabfd3de82436391e1873d084c36416c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474fe4581380191919f9d713834d6361"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga474fe4581380191919f9d713834d6361">NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE</a>(type)&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE_, type))</td></tr>
<tr class="memdesc:ga474fe4581380191919f9d713834d6361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to calculate size required to hold a ECC public key given curve type(domain), according to the used nrf_crypto backend.  <a href="#ga474fe4581380191919f9d713834d6361">More...</a><br/></td></tr>
<tr class="separator:ga474fe4581380191919f9d713834d6361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c20b51908dc82ba5834a09133a06cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gab8c20b51908dc82ba5834a09133a06cf">NRF_CRYPTO_ECC_PRIVATE_KEY_CREATE</a>(name, type)</td></tr>
<tr class="memdesc:gab8c20b51908dc82ba5834a09133a06cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an instance of an ECC private key given name and type.  <a href="#gab8c20b51908dc82ba5834a09133a06cf">More...</a><br/></td></tr>
<tr class="separator:gab8c20b51908dc82ba5834a09133a06cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa858181cd60cabb03f66830270ee34a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gaa858181cd60cabb03f66830270ee34a5">NRF_CRYPTO_ECC_PUBLIC_KEY_CREATE</a>(name, type)</td></tr>
<tr class="memdesc:gaa858181cd60cabb03f66830270ee34a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an instance of an ECC public key by a given name and type.  <a href="#gaa858181cd60cabb03f66830270ee34a5">More...</a><br/></td></tr>
<tr class="separator:gaa858181cd60cabb03f66830270ee34a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a5b13ea5fc0ed8962c8d343725f6d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga33a5b13ea5fc0ed8962c8d343725f6d0">NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE</a>(type)&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE_, type))</td></tr>
<tr class="memdesc:ga33a5b13ea5fc0ed8962c8d343725f6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to calculate size required to hold a ECC private key in raw format given curve type(domain), according to the used nrf_crypto backend.  <a href="#ga33a5b13ea5fc0ed8962c8d343725f6d0">More...</a><br/></td></tr>
<tr class="separator:ga33a5b13ea5fc0ed8962c8d343725f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9a0cd0327182c656ca39d167390b08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gabc9a0cd0327182c656ca39d167390b08">NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE</a>(type)&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE_, type))</td></tr>
<tr class="memdesc:gabc9a0cd0327182c656ca39d167390b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal macro to calculate size required to hold a ECC public key in raw representatio given curve type(domain), according to the used nrf_crypto backend.  <a href="#gabc9a0cd0327182c656ca39d167390b08">More...</a><br/></td></tr>
<tr class="separator:gabc9a0cd0327182c656ca39d167390b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176ca2f49c060332fecd224eff460893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga176ca2f49c060332fecd224eff460893">NRF_CRYPTO_ECC_PRIVATE_KEY_RAW_CREATE</a>(name, type)</td></tr>
<tr class="memdesc:ga176ca2f49c060332fecd224eff460893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an instance of a raw representation of an ECC private key given name and type.  <a href="#ga176ca2f49c060332fecd224eff460893">More...</a><br/></td></tr>
<tr class="separator:ga176ca2f49c060332fecd224eff460893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a93e7728ab0ccf744504e8f8cb014c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga61a93e7728ab0ccf744504e8f8cb014c">NRF_CRYPTO_ECC_PRIVATE_KEY_RAW_CREATE_FROM_ARRAY</a>(name, type, input)</td></tr>
<tr class="memdesc:ga61a93e7728ab0ccf744504e8f8cb014c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create a value length structure to represent a raw ECC private key by a given name, type and an uint8_t array buffer to hold the raw private key. If the input is not of the correct size a static assert will be occur compile-time.  <a href="#ga61a93e7728ab0ccf744504e8f8cb014c">More...</a><br/></td></tr>
<tr class="separator:ga61a93e7728ab0ccf744504e8f8cb014c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf5b8447d50ae51ca6a91a1fd116142"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga8bf5b8447d50ae51ca6a91a1fd116142">NRF_CRYPTO_ECC_PUBLIC_KEY_RAW_CREATE</a>(name, type)</td></tr>
<tr class="memdesc:ga8bf5b8447d50ae51ca6a91a1fd116142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an instance of a araw representation of an ECC public key given name and type.  <a href="#ga8bf5b8447d50ae51ca6a91a1fd116142">More...</a><br/></td></tr>
<tr class="separator:ga8bf5b8447d50ae51ca6a91a1fd116142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada01b4607598d7c50d88db417756fa69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gada01b4607598d7c50d88db417756fa69">NRF_CRYPTO_ECC_PUBLIC_KEY_RAW_CREATE_FROM_ARRAY</a>(name, type, input)</td></tr>
<tr class="memdesc:gada01b4607598d7c50d88db417756fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create an instance of an ECC public key by a given name, type and array input. If the input is not of the correct size a static assert will be occur compile-time.  <a href="#gada01b4607598d7c50d88db417756fa69">More...</a><br/></td></tr>
<tr class="separator:gada01b4607598d7c50d88db417756fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac19961eaf6d91b0592266466fa0d2c49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gac19961eaf6d91b0592266466fa0d2c49">nrf_crypto_ecc_private_key_size_get</a> (<a class="el" href="group___n_r_f___c_r_y_p_t_o___c_u_r_v_e_s.html#gabde29f2db7db3778a394ed681ea916c0">nrf_ecc_curve_type_t</a> curve_type, uint32_t *p_key_size)</td></tr>
<tr class="memdesc:gac19961eaf6d91b0592266466fa0d2c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the private key size given curve_type.  <a href="#gac19961eaf6d91b0592266466fa0d2c49">More...</a><br/></td></tr>
<tr class="separator:gac19961eaf6d91b0592266466fa0d2c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fe035ca91ca85c1590aaa636268dd4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga90fe035ca91ca85c1590aaa636268dd4">nrf_crypto_ecc_public_key_size_get</a> (<a class="el" href="group___n_r_f___c_r_y_p_t_o___c_u_r_v_e_s.html#gabde29f2db7db3778a394ed681ea916c0">nrf_ecc_curve_type_t</a> curve_type, uint32_t *p_key_size)</td></tr>
<tr class="memdesc:ga90fe035ca91ca85c1590aaa636268dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the public key size given curve_type.  <a href="#ga90fe035ca91ca85c1590aaa636268dd4">More...</a><br/></td></tr>
<tr class="separator:ga90fe035ca91ca85c1590aaa636268dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4171baa0c4bf5bf0a680475c0fc65522"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga4171baa0c4bf5bf0a680475c0fc65522">nrf_crypto_ecc_private_key_allocate</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_private_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *p_raw_key)</td></tr>
<tr class="memdesc:ga4171baa0c4bf5bf0a680475c0fc65522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to allocate dynamic memory for holding a ECC private key.  <a href="#ga4171baa0c4bf5bf0a680475c0fc65522">More...</a><br/></td></tr>
<tr class="separator:ga4171baa0c4bf5bf0a680475c0fc65522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3706e5e25b070a038ff73c4e0415994e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga3706e5e25b070a038ff73c4e0415994e">nrf_crypto_ecc_private_key_free</a> (<a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_private_key)</td></tr>
<tr class="memdesc:ga3706e5e25b070a038ff73c4e0415994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to free allocated memory for ECC private key.  <a href="#ga3706e5e25b070a038ff73c4e0415994e">More...</a><br/></td></tr>
<tr class="separator:ga3706e5e25b070a038ff73c4e0415994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd3b45bb98ca120962813152b2bd2ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga3cd3b45bb98ca120962813152b2bd2ef">nrf_crypto_ecc_public_key_allocate</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *p_raw_key)</td></tr>
<tr class="memdesc:ga3cd3b45bb98ca120962813152b2bd2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to allocate dynamic memory for holdign a ECC public key.  <a href="#ga3cd3b45bb98ca120962813152b2bd2ef">More...</a><br/></td></tr>
<tr class="separator:ga3cd3b45bb98ca120962813152b2bd2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cdc93ebe73526720fff36113a5ef65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga40cdc93ebe73526720fff36113a5ef65">nrf_crypto_ecc_public_key_free</a> (<a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key)</td></tr>
<tr class="memdesc:ga40cdc93ebe73526720fff36113a5ef65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to free allocated memory for ECC private key.  <a href="#ga40cdc93ebe73526720fff36113a5ef65">More...</a><br/></td></tr>
<tr class="separator:ga40cdc93ebe73526720fff36113a5ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922c3fe551ac3a6e82cdda13bff2fadd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga922c3fe551ac3a6e82cdda13bff2fadd">nrf_crypto_ecc_key_pair_generate</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_private_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key)</td></tr>
<tr class="memdesc:ga922c3fe551ac3a6e82cdda13bff2fadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate ECC private public keypair given curve type.  <a href="#ga922c3fe551ac3a6e82cdda13bff2fadd">More...</a><br/></td></tr>
<tr class="separator:ga922c3fe551ac3a6e82cdda13bff2fadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ad87e92eb0394f898d31654792ee5e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga38ad87e92eb0394f898d31654792ee5e">nrf_crypto_ecc_public_key_calculate</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *p_private_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key)</td></tr>
<tr class="memdesc:ga38ad87e92eb0394f898d31654792ee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate ECC public key given a ECC private key as input.  <a href="#ga38ad87e92eb0394f898d31654792ee5e">More...</a><br/></td></tr>
<tr class="separator:ga38ad87e92eb0394f898d31654792ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a87b32df5327dc331998f207b7edce"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga75a87b32df5327dc331998f207b7edce">nrf_crypto_ecc_private_key_to_raw</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *p_private_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_private_key_raw)</td></tr>
<tr class="memdesc:ga75a87b32df5327dc331998f207b7edce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert ECC private key to a raw representation for use in external APIs.  <a href="#ga75a87b32df5327dc331998f207b7edce">More...</a><br/></td></tr>
<tr class="separator:ga75a87b32df5327dc331998f207b7edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac8c26d1df4fb6d57a69cda54673dc1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#ga4ac8c26d1df4fb6d57a69cda54673dc1">nrf_crypto_ecc_public_key_to_raw</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *p_public_key, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key_raw)</td></tr>
<tr class="memdesc:ga4ac8c26d1df4fb6d57a69cda54673dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert ECC public key to a raw representation for use in external APIs.  <a href="#ga4ac8c26d1df4fb6d57a69cda54673dc1">More...</a><br/></td></tr>
<tr class="separator:ga4ac8c26d1df4fb6d57a69cda54673dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9eae3c15bb4bdcdbf5ac03ff8a784de"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__crypto__keys.html#gac9eae3c15bb4bdcdbf5ac03ff8a784de">nrf_crypto_ecc_public_key_from_raw</a> (<a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a> curve_info, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key_raw, <a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *p_public_key)</td></tr>
<tr class="memdesc:gac9eae3c15bb4bdcdbf5ac03ff8a784de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert ECC public key from a raw representation for use in nrf_crypto API.  <a href="#gac9eae3c15bb4bdcdbf5ac03ff8a784de">More...</a><br/></td></tr>
<tr class="separator:gac9eae3c15bb4bdcdbf5ac03ff8a784de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides functions to allocate, free, generate and convert ECC key types. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab8c20b51908dc82ba5834a09133a06cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PRIVATE_KEY_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__ALIGN(4) static uint8_t                                                               \</div>
<div class="line">    name <span class="preprocessor">## _buffer[NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE(type)];                             \</span></div>
<div class="line"><span class="preprocessor">nrf_value_length_t name =                                                               \</span></div>
<div class="line"><span class="preprocessor">{                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    .p_value = name ## _buffer,                                                         \</span></div>
<div class="line"><span class="preprocessor">    .length = NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE(type)                                     \</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment -->
<p>Macro to create an instance of an ECC private key given name and type. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for Nordic APIs with a buffer to hold the actual ECC private key data. The ECC private key type is opaque and the size and format of the data is dependant on the nrf_crypto backend.</dd>
<dd>
To convert this key to a raw representation required for external APIS, please use the function <a class="el" href="group__nrf__crypto__keys.html#ga4ac8c26d1df4fb6d57a69cda54673dc1">nrf_crypto_ecc_public_key_to_raw</a>. This may not be supported by all nrf_crypto backends.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC private key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga176ca2f49c060332fecd224eff460893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PRIVATE_KEY_RAW_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__ALIGN(4) static uint8_t                                                               \</div>
<div class="line">    name <span class="preprocessor">## _buffer[NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE(type)];                         \</span></div>
<div class="line"><span class="preprocessor">nrf_value_length_t name =                                                               \</span></div>
<div class="line"><span class="preprocessor">{                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    .p_value = name ## _buffer,                                                         \</span></div>
<div class="line"><span class="preprocessor">    .length = NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE(type)                                 \</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment -->
<p>Macro to create an instance of a raw representation of an ECC private key given name and type. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for external APIs that require an aligned version of a private key where curve-domain and endianness is described elsewhere.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The raw private key can not be used directly in the nrf_crypto APIs.</dd>
<dd>
The output of this macro is subject to change.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC private key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61a93e7728ab0ccf744504e8f8cb014c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PRIVATE_KEY_RAW_CREATE_FROM_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__nrf__esb.html#ga07e13de8ecdbf181d7b526cadfb364e5">STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(input) == <a class="code" href="group__nrf__crypto__keys.html#ga33a5b13ea5fc0ed8962c8d343725f6d0" title="Internal macro to calculate size required to hold a ECC private key in raw format given curve type(do...">NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE</a>(type))               \</div>
<div class="line">static <a class="code" href="structnrf__value__length__t.html" title="Generic type to hold pointer to value and length.">nrf_value_length_t</a> name =                                                        \</div>
<div class="line">{                                                                                       \</div>
<div class="line">    .p_value = (uint8_t*)input,                                                         \</div>
<div class="line">    .length = <a class="code" href="group__nrf__crypto__keys.html#ga33a5b13ea5fc0ed8962c8d343725f6d0" title="Internal macro to calculate size required to hold a ECC private key in raw format given curve type(do...">NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE</a>(type)                                 \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro to create a value length structure to represent a raw ECC private key by a given name, type and an uint8_t array buffer to hold the raw private key. If the input is not of the correct size a static assert will be occur compile-time. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for external APIs that require an aligned version of a private key where curve-domain and endianness is described elsewhere.</dd>
<dd>
The value length pair generated by running this macro can be used as input in the function <a class="el" href="group__nrf__crypto__keys.html#ga75a87b32df5327dc331998f207b7edce">nrf_crypto_ecc_private_key_to_raw</a> to hold a raw private key type.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>There is no API function to convert private key from a raw representation in the nrf_crypto CryptoCell (cc310) backend. Running this macro while nrf_crypto CryptoCell backend is enabled will cause a static assertion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC private key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array holding the private key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfd3de82436391e1873d084c36416c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE_, type))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal macro to calculate size required to hold a ECC private key given curve type(domain), according to the used nrf_crypto backend. </p>
<dl class="section warning"><dt>Warning</dt><dd>The size representation by running this macro is described by the memory requirements of the nrf_crypto backend. This size does not correspond to the size required to hold a raw key. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33a5b13ea5fc0ed8962c8d343725f6d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PRIVATE_RAW_KEY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PRIVATE_KEY_SIZE_, type))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal macro to calculate size required to hold a ECC private key in raw format given curve type(domain), according to the used nrf_crypto backend. </p>
<dl class="section warning"><dt>Warning</dt><dd>The size representation by running this macro is described by the memory requirements of the nrf_crypto backend. This size does not correspond to the size required to hold a raw key. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa858181cd60cabb03f66830270ee34a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PUBLIC_KEY_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__ALIGN(4) static uint8_t                                                               \</div>
<div class="line">    name <span class="preprocessor">## _buffer[NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE(type)];                              \</span></div>
<div class="line"><span class="preprocessor">nrf_value_length_t name =                                                               \</span></div>
<div class="line"><span class="preprocessor">{                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    .p_value = name ## _buffer,                                                         \</span></div>
<div class="line"><span class="preprocessor">    .length = NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE(type)                                      \</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment -->
<p>Macro to create an instance of an ECC public key by a given name and type. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for Nordic APIs with a buffer to hold the actual ECC public key data. The ECC public key type is opaque and the size and format of the data is dependant on the nrf_crypto backend.</dd>
<dd>
To convert this key to a raw representation required for external APIS, please use the function <a class="el" href="group__nrf__crypto__keys.html#ga4ac8c26d1df4fb6d57a69cda54673dc1">nrf_crypto_ecc_public_key_to_raw</a>. This may not be supported by all nrf_crypto backends.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC PUBLIC key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bf5b8447d50ae51ca6a91a1fd116142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PUBLIC_KEY_RAW_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__ALIGN(4) static uint8_t                                                               \</div>
<div class="line">    name <span class="preprocessor">## _buffer[NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE(type)];                          \</span></div>
<div class="line"><span class="preprocessor">nrf_value_length_t name =                                                               \</span></div>
<div class="line"><span class="preprocessor">{                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    .p_value = name ## _buffer,                                                         \</span></div>
<div class="line"><span class="preprocessor">    .length = NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE(type)                                  \</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment -->
<p>Macro to create an instance of a araw representation of an ECC public key given name and type. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for external APIs that require an aligned version of a public key where curve-domain and endianness is described elsewhere.</dd></dl>
<p>¨*</p>
<dl class="section note"><dt>Note</dt><dd>The value length pair generated by running this macro can be used as input in the function <a class="el" href="group__nrf__crypto__keys.html#ga4ac8c26d1df4fb6d57a69cda54673dc1">nrf_crypto_ecc_public_key_to_raw</a> to hold a raw private key type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC PUBLIC key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada01b4607598d7c50d88db417756fa69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PUBLIC_KEY_RAW_CREATE_FROM_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__nrf__esb.html#ga07e13de8ecdbf181d7b526cadfb364e5">STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(input) == <a class="code" href="group__nrf__crypto__keys.html#gabc9a0cd0327182c656ca39d167390b08" title="Internal macro to calculate size required to hold a ECC public key in raw representatio given curve t...">NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE</a>(type));               \</div>
<div class="line">static <a class="code" href="structnrf__value__length__t.html" title="Generic type to hold pointer to value and length.">nrf_value_length_t</a> name =                                                        \</div>
<div class="line">{                                                                                       \</div>
<div class="line">    .p_value = (uint8_t*)input,                                                         \</div>
<div class="line">    .length = <a class="code" href="group__nrf__crypto__keys.html#gabc9a0cd0327182c656ca39d167390b08" title="Internal macro to calculate size required to hold a ECC public key in raw representatio given curve t...">NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE</a>(type)                                  \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro to create an instance of an ECC public key by a given name, type and array input. If the input is not of the correct size a static assert will be occur compile-time. </p>
<dl class="section note"><dt>Note</dt><dd>This creates the value length structure used for external APIs that require an aligned version of a private key where curve-domain and endianness is described elsewhere.</dd>
<dd>
The value length pair generated by running this macro can be used as input in the function <a class="el" href="group__nrf__crypto__keys.html#ga75a87b32df5327dc331998f207b7edce">nrf_crypto_ecc_private_key_to_raw</a> to hold a raw public key type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the ECC PUBLIC key instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of data used as the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga474fe4581380191919f9d713834d6361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE_, type))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal macro to calculate size required to hold a ECC public key given curve type(domain), according to the used nrf_crypto backend. </p>
<dl class="section warning"><dt>Warning</dt><dd>The size representation by running this macro is described by the memory requirements of the nrf_crypto backend. This size does not correspond to the size required to hold a raw key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc9a0cd0327182c656ca39d167390b08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_CRYPTO_ECC_PUBLIC_RAW_KEY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__app__util.html#ga89cebe2a95b9e0202f39f28d61c59ae8">STRING_CONCATENATE</a>(NRF_CRYPTO_ECC_PUBLIC_KEY_SIZE_, type))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal macro to calculate size required to hold a ECC public key in raw representatio given curve type(domain), according to the used nrf_crypto backend. </p>
<dl class="section warning"><dt>Warning</dt><dd>The size representation by running this macro is described by the memory requirements of the nrf_crypto backend. This size does not correspond to the size required to hold a raw key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Curve type. Either SECP192R1, SECP224R1, SECP256R1, SECP384R1, SECP521R1, SECP192K1, SECP224K1, or SECP256K1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga922c3fe551ac3a6e82cdda13bff2fadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_key_pair_generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to generate ECC private public keypair given curve type. </p>
<dl class="section note"><dt>Note</dt><dd>This function will not allocate any memory. Private and public keys given as input must be pointing to previously allocated memory.</dd>
<dd>
This function needs RNG functionality. See <a class="el" href="group__nrf__crypto__config.html#ga3cd685588046e17dce157e07b353a5a9">NRF_CRYPTO_SUPPORTS_RNG</a> for the nrf_crypto backends that require external source of RNG data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Curve type used for key pair generation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_private_key</td><td>Pointer to a value length structure to hold a private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_public_key</td><td>Pointer to a value length structure to hold a public key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>The ECC key pair was generated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the function was called when nrf_crypto was uninitialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the any of the parameters was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If any of the provided pointers are invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If the key pair size is different to the provided buffers. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the key pair generation is not supported for the given curve type. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>Unexpected error. Possibly because <a class="el" href="group__nrf__crypto__config.html#ga3cd685588046e17dce157e07b353a5a9">NRF_CRYPTO_SUPPORTS_RNG</a> is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4171baa0c4bf5bf0a680475c0fc65522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_private_key_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *&#160;</td>
          <td class="paramname"><em>p_raw_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to allocate dynamic memory for holding a ECC private key. </p>
<dl class="section note"><dt>Note</dt><dd>Memory dynamically allocated by calling this function will be aligned to a uint32_t address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Curve type used for ECC private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_private_key</td><td>Pointer to a value length structure to hold a private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_raw_key</td><td>Pointer to value length structure holding raw representation of a private key taken as input. If this is set to NULL, no initialization will take place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If memory for the private key was successfully allocated. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If p_private_key was NULL. </td></tr>
    <tr><td class="paramname">Any</td><td>other error code reported by the memory manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3706e5e25b070a038ff73c4e0415994e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_private_key_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_private_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to free allocated memory for ECC private key. </p>
<dl class="section note"><dt>Note</dt><dd>Memory dynamically allocated by calling this function will be aligned to a uint32_t address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_private_key</td><td>Pointer to structure holdign</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>if memory for the private key was successfully freed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If p_private_key was NULL. </td></tr>
    <tr><td class="paramname">Any</td><td>other error code reported by the memory manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac19961eaf6d91b0592266466fa0d2c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_private_key_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___c_r_y_p_t_o___c_u_r_v_e_s.html#gabde29f2db7db3778a394ed681ea916c0">nrf_ecc_curve_type_t</a>&#160;</td>
          <td class="paramname"><em>curve_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the private key size given curve_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_type</td><td>Curve type to get private key size for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_key_size</td><td>Pointer to variable to hold the private key size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the private key size was successfully found. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the p_key_size was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the curve type was not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75a87b32df5327dc331998f207b7edce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_private_key_to_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *&#160;</td>
          <td class="paramname"><em>p_private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_private_key_raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert ECC private key to a raw representation for use in external APIs. </p>
<dl class="section note"><dt>Note</dt><dd>This function will not allocate any memory. The raw public key given as output parameter must be pointing to previously allocated memory.</dd>
<dd>
The format of the data for the converted ECC public key must be aligned and will use the least amount of space required to represent the key.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The nrf_crypto backend may not support converting a private key to a raw representation. This is subject to change.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Info of the curve type (domain) and the endianness of the resulting raw key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_private_key</td><td>Value length structure holding a private key to be converted to a raw representation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_private_key_raw</td><td>Value length structure to hold the converted private key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the private key was converted to raw representation. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the function was called when nrf_crypto was uninitialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the any of the parameters was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If any of the provided pointers are invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If the size of the public key and result is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the selected curve is not supported. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_DATA</td><td>If the private key was deemed invalid by the nrf_crypto backend. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occured in the nrf_crypto backend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3cd3b45bb98ca120962813152b2bd2ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *&#160;</td>
          <td class="paramname"><em>p_raw_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to allocate dynamic memory for holdign a ECC public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Curve type used for ECC public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_public_key</td><td>Pointer to a value length structure to hold a public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_raw_key</td><td>Pointer to value length structure holding raw representation of a public key taken as input. If this is set to NULL, no initialization will take place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If memory for the public key was successfully allocated. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If p_public_key was NULL. </td></tr>
    <tr><td class="paramname">Any</td><td>other error code reported by the memory manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38ad87e92eb0394f898d31654792ee5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_calculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *&#160;</td>
          <td class="paramname"><em>p_private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate ECC public key given a ECC private key as input. </p>
<dl class="section note"><dt>Note</dt><dd>This function will not allocate any memory. The public key given as input must be pointing to previously allocated memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Curve type used for public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_private_key</td><td>Pointer to a value length structure holding a private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_public_key</td><td>Pointer to a value length structure to hold the calculated key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the public key was calculated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the function was called when nrf_crypto was uninitialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the any of the parameters was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If any of the provided pointers are invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If the key pair size is different to the provided buffers. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the public key calculation is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40cdc93ebe73526720fff36113a5ef65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to free allocated memory for ECC private key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_public_key</td><td>Pointer to value length structure holding public key to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If memory for the public key was successfully freed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If p_public_key was NULL. </td></tr>
    <tr><td class="paramname">Any</td><td>other error code reported by the memory manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9eae3c15bb4bdcdbf5ac03ff8a784de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_from_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key_raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert ECC public key from a raw representation for use in nrf_crypto API. </p>
<dl class="section note"><dt>Note</dt><dd>This function will not allocate any memory. The public key given as output parameter must be pointing to previously allocated memory. The format of the data for the converted ECC public key must be aligned and will use the least amount of space required to represent the key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Info of the curve type (domain) and the endianness of the raw public key given as input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_public_key_raw</td><td>Value length structure to hold the converted public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_public_key</td><td>Value length structure holding a private key to be converted to a raw representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the public key was converted fron raw representation. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the function was called when nrf_crypto was uninitialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the any of the parameters was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If any of the provided pointers are invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the selected curve is not supported. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If the size of the public key and result is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_DATA</td><td>If the public key was deemed invalid by the nrf_crypto backend. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occured in the nrf_crypto backend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90fe035ca91ca85c1590aaa636268dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___c_r_y_p_t_o___c_u_r_v_e_s.html#gabde29f2db7db3778a394ed681ea916c0">nrf_ecc_curve_type_t</a>&#160;</td>
          <td class="paramname"><em>curve_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the public key size given curve_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_type</td><td>Curve type to get public key size for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_key_size</td><td>Pointer to variable to hold the public key size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the public key size was successfully found. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the p_key_size was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the curve type was not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ac8c26d1df4fb6d57a69cda54673dc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_crypto_ecc_public_key_to_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__crypto__curve__info__t.html">nrf_crypto_curve_info_t</a>&#160;</td>
          <td class="paramname"><em>curve_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> const *&#160;</td>
          <td class="paramname"><em>p_public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__value__length__t.html">nrf_value_length_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key_raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert ECC public key to a raw representation for use in external APIs. </p>
<dl class="section note"><dt>Note</dt><dd>This function will not allocate any memory. The raw public key given as output parameter must be pointing to previously allocated memory. The format of the data for the converted ECC public key must be aligned and will use the least amount of space required to represent the key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve_info</td><td>Info of the curve type (domain) and the endianness of the resulting raw key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_public_key</td><td>Value length structure holding a public key to be converted to a raw representation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_public_key_raw</td><td>Value length structure to hold the converted public key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the public key was converted to raw representation. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the function was called when nrf_crypto was uninitialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If the any of the parameters was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If any of the provided pointers are invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If the size of the public key and result is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If the selected curve is not supported. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_DATA</td><td>If the public key was deemed invalid by the nrf_crypto backend. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occured in the nrf_crypto backend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri Mar 10 2017" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
