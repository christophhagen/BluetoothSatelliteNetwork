<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v13.0.0: fstorage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v13.0.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<!--<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>-->
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s132","s140","s212","s332"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fstorage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fstorage<div class="ingroups"><a class="el" href="group__app__common.html">SDK common libraries</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Module which provides functionality to store data to flash and erase flash pages.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__fstorage__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage__config.html">Flash storage module configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__evt__t.html">fs_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An fstorage event.  <a href="structfs__evt__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__config__t.html">fs_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fstorage application-specific configuration.  <a href="structfs__config__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7b6937b812d30a80760ca578262a19b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga7b6937b812d30a80760ca578262a19b8">FS_REGISTER_CFG</a>(cfg_var)&#160;&#160;&#160;<a class="el" href="group__section__vars.html#gacc2a038db0790a770a318bbed65c43c3">NRF_SECTION_ITEM_REGISTER</a>(fs_data, cfg_var)</td></tr>
<tr class="memdesc:ga7b6937b812d30a80760ca578262a19b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for registering an fstorage configuration variable. Applications which use fstorage must register with the module using this macro. Registering involves defining a variable which holds the configuration of fstorage specific to the application which invokes the macro.  <a href="#ga7b6937b812d30a80760ca578262a19b8">More...</a><br/></td></tr>
<tr class="separator:ga7b6937b812d30a80760ca578262a19b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga19f7030feb3bed0c9919c2cf213a5f1e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga19f7030feb3bed0c9919c2cf213a5f1e">fs_cb_t</a> )(<a class="el" href="structfs__evt__t.html">fs_evt_t</a> const *const evt, <a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> result)</td></tr>
<tr class="memdesc:ga19f7030feb3bed0c9919c2cf213a5f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">fstorage event handler function prototype.  <a href="#ga19f7030feb3bed0c9919c2cf213a5f1e">More...</a><br/></td></tr>
<tr class="separator:ga19f7030feb3bed0c9919c2cf213a5f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7d7c3e91fa4f4614eaf115069db12374"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> { <br/>
&#160;&#160;<b>FS_SUCCESS</b>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374ab62d0f2016f5af76e5a3469739eeb1eb">FS_ERR_NOT_INITIALIZED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a7e1e61c0bc7e94ae4961871e6329fa5b">FS_ERR_INVALID_CFG</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a972387d4332de0b26da544816f998667">FS_ERR_NULL_ARG</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a81a0cc60142ee140efd2e499415aa4de">FS_ERR_INVALID_ARG</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374aaba1f7bcef984f946b71c4e6344af2d6">FS_ERR_INVALID_ADDR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374acc1871e21d2dbc3a550ee9ea354f0307">FS_ERR_UNALIGNED_ADDR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a2843be8594a4236cb9f809b00ba313f1">FS_ERR_QUEUE_FULL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a116a66dc133bc6eb4367f1c52750e24a">FS_ERR_OPERATION_TIMEOUT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a01381c31b16e84f370a1a55cc3a5ff5c">FS_ERR_INTERNAL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga7d7c3e91fa4f4614eaf115069db12374a7a4bc74a2feac2b65a22ed7dae8bed05">FS_ERR_FAILURE_SINCE_LAST</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga7d7c3e91fa4f4614eaf115069db12374"><td class="mdescLeft">&#160;</td><td class="mdescRight">fstorage return values.  <a href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">More...</a><br/></td></tr>
<tr class="separator:ga7d7c3e91fa4f4614eaf115069db12374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd53b24a24460785afc79e6c0acd7b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga9dd53b24a24460785afc79e6c0acd7b8">fs_evt_id_t</a> { <br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga9dd53b24a24460785afc79e6c0acd7b8a42248cb2a6273194d4bee3117760ab89">FS_EVT_STORE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__fstorage.html#gga9dd53b24a24460785afc79e6c0acd7b8ad9aec936b28a9f04ffd83d8ca967b43d">FS_EVT_ERASE</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga9dd53b24a24460785afc79e6c0acd7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">fstorage event IDs.  <a href="group__fstorage.html#ga9dd53b24a24460785afc79e6c0acd7b8">More...</a><br/></td></tr>
<tr class="separator:ga9dd53b24a24460785afc79e6c0acd7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga26dabfb4f9594822d7762803caa932d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga26dabfb4f9594822d7762803caa932d9">fs_init</a> (void)</td></tr>
<tr class="memdesc:ga26dabfb4f9594822d7762803caa932d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the module.  <a href="#ga26dabfb4f9594822d7762803caa932d9">More...</a><br/></td></tr>
<tr class="separator:ga26dabfb4f9594822d7762803caa932d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0411eacb539c353f407950ecf6bde66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0411eacb539c353f407950ecf6bde66"></a>
<a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fs_fake_init</b> (void)</td></tr>
<tr class="separator:gaa0411eacb539c353f407950ecf6bde66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94976860d509d5c8d28c6d3bbb9a059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#gaf94976860d509d5c8d28c6d3bbb9a059">fs_store</a> (<a class="el" href="structfs__config__t.html">fs_config_t</a> const *const p_config, uint32_t const *const p_dest, uint32_t const *const p_src, uint16_t length_words, void *p_context)</td></tr>
<tr class="memdesc:gaf94976860d509d5c8d28c6d3bbb9a059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for storing data in flash.  <a href="#gaf94976860d509d5c8d28c6d3bbb9a059">More...</a><br/></td></tr>
<tr class="separator:gaf94976860d509d5c8d28c6d3bbb9a059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0428a1e8a5988a9d031f67ce67ff8eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga0428a1e8a5988a9d031f67ce67ff8eb1">fs_erase</a> (<a class="el" href="structfs__config__t.html">fs_config_t</a> const *const p_config, uint32_t const *const p_page_addr, uint16_t num_pages, void *p_context)</td></tr>
<tr class="memdesc:ga0428a1e8a5988a9d031f67ce67ff8eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for erasing flash pages.  <a href="#ga0428a1e8a5988a9d031f67ce67ff8eb1">More...</a><br/></td></tr>
<tr class="separator:ga0428a1e8a5988a9d031f67ce67ff8eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30139880a5d7d80dfc877840ce71c1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga30139880a5d7d80dfc877840ce71c1a7">fs_queued_op_count_get</a> (uint32_t *const p_op_count)</td></tr>
<tr class="memdesc:ga30139880a5d7d80dfc877840ce71c1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the number of queued flash operations.  <a href="#ga30139880a5d7d80dfc877840ce71c1a7">More...</a><br/></td></tr>
<tr class="separator:ga30139880a5d7d80dfc877840ce71c1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37b0b1b485f017f8599d6f2ffda2821"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#gae37b0b1b485f017f8599d6f2ffda2821">fs_queue_is_full</a> (void)</td></tr>
<tr class="memdesc:gae37b0b1b485f017f8599d6f2ffda2821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the queue for flash operations is full.  <a href="#gae37b0b1b485f017f8599d6f2ffda2821">More...</a><br/></td></tr>
<tr class="separator:gae37b0b1b485f017f8599d6f2ffda2821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b0b759ae47b1a89ab23a03a1c570e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#gab5b0b759ae47b1a89ab23a03a1c570e1">fs_queue_is_empty</a> (void)</td></tr>
<tr class="memdesc:gab5b0b759ae47b1a89ab23a03a1c570e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the queue for flash operations is empty.  <a href="#gab5b0b759ae47b1a89ab23a03a1c570e1">More...</a><br/></td></tr>
<tr class="separator:gab5b0b759ae47b1a89ab23a03a1c570e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcde5d157fe6048ca55c0ff3d403f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fstorage.html#ga1fcde5d157fe6048ca55c0ff3d403f74">fs_sys_event_handler</a> (uint32_t sys_evt)</td></tr>
<tr class="memdesc:ga1fcde5d157fe6048ca55c0ff3d403f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for handling system events from the SoftDevice.  <a href="#ga1fcde5d157fe6048ca55c0ff3d403f74">More...</a><br/></td></tr>
<tr class="separator:ga1fcde5d157fe6048ca55c0ff3d403f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module which provides functionality to store data to flash and erase flash pages. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7b6937b812d30a80760ca578262a19b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_REGISTER_CFG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cfg_var</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__section__vars.html#gacc2a038db0790a770a318bbed65c43c3">NRF_SECTION_ITEM_REGISTER</a>(fs_data, cfg_var)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for registering an fstorage configuration variable. Applications which use fstorage must register with the module using this macro. Registering involves defining a variable which holds the configuration of fstorage specific to the application which invokes the macro. </p>
<p>This macro places the configuration variable in a section named "fs_data" that fstorage uses during initialization and regular operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg_var</td><td>A <em>definition</em> of a <a class="el" href="structfs__config__t.html">fs_config_t</a> variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga19f7030feb3bed0c9919c2cf213a5f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fs_cb_t)(<a class="el" href="structfs__evt__t.html">fs_evt_t</a> const *const evt, <a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fstorage event handler function prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evt</td><td>The event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>The result of the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga9dd53b24a24460785afc79e6c0acd7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fstorage.html#ga9dd53b24a24460785afc79e6c0acd7b8">fs_evt_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fstorage event IDs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga9dd53b24a24460785afc79e6c0acd7b8a42248cb2a6273194d4bee3117760ab89"></a>FS_EVT_STORE</em>&nbsp;</td><td class="fielddoc">
<p>Event for <a class="el" href="group__fstorage.html#gaf94976860d509d5c8d28c6d3bbb9a059">fs_store</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9dd53b24a24460785afc79e6c0acd7b8ad9aec936b28a9f04ffd83d8ca967b43d"></a>FS_EVT_ERASE</em>&nbsp;</td><td class="fielddoc">
<p>Event for <a class="el" href="group__fstorage.html#ga0428a1e8a5988a9d031f67ce67ff8eb1">fs_erase</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7d7c3e91fa4f4614eaf115069db12374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fstorage return values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374ab62d0f2016f5af76e5a3469739eeb1eb"></a>FS_ERR_NOT_INITIALIZED</em>&nbsp;</td><td class="fielddoc">
<p>Error. The module is not initialized. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a7e1e61c0bc7e94ae4961871e6329fa5b"></a>FS_ERR_INVALID_CFG</em>&nbsp;</td><td class="fielddoc">
<p>Error. Invalid fstorage configuration. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a972387d4332de0b26da544816f998667"></a>FS_ERR_NULL_ARG</em>&nbsp;</td><td class="fielddoc">
<p>Error. Argument is NULL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a81a0cc60142ee140efd2e499415aa4de"></a>FS_ERR_INVALID_ARG</em>&nbsp;</td><td class="fielddoc">
<p>Error. Argument contains invalid data. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374aaba1f7bcef984f946b71c4e6344af2d6"></a>FS_ERR_INVALID_ADDR</em>&nbsp;</td><td class="fielddoc">
<p>Error. Address out of bounds. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374acc1871e21d2dbc3a550ee9ea354f0307"></a>FS_ERR_UNALIGNED_ADDR</em>&nbsp;</td><td class="fielddoc">
<p>Error. Unaligned address. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a2843be8594a4236cb9f809b00ba313f1"></a>FS_ERR_QUEUE_FULL</em>&nbsp;</td><td class="fielddoc">
<p>Error. Queue is full. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a116a66dc133bc6eb4367f1c52750e24a"></a>FS_ERR_OPERATION_TIMEOUT</em>&nbsp;</td><td class="fielddoc">
<p>Error. The operation has timed out. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a01381c31b16e84f370a1a55cc3a5ff5c"></a>FS_ERR_INTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Error. Internal error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7d7c3e91fa4f4614eaf115069db12374a7a4bc74a2feac2b65a22ed7dae8bed05"></a>FS_ERR_FAILURE_SINCE_LAST</em>&nbsp;</td><td class="fielddoc">
<p>Error. Uncleared error since last call. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0428a1e8a5988a9d031f67ce67ff8eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> fs_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfs__config__t.html">fs_config_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *const&#160;</td>
          <td class="paramname"><em>p_page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for erasing flash pages. </p>
<p>Starting from the page at <code>p_page_addr</code>, erases <code>num_pages</code> flash pages. <code>p_page_addr</code> must be aligned to a page boundary. All pages to be erased must be within the bounds specified in the supplied fstorage configuration. This function is asynchronous. Completion is reported via an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>fstorage configuration registered by the application. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_page_addr</td><td>Address of the page to erase. Must be aligned to a page boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pages</td><td>Number of pages to erase. May not be zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>User-defined context passed to the interrupt handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_CFG</td><td>If <code>p_config</code> is NULL or contains invalid data. </td></tr>
    <tr><td class="paramname">FS_ERR_NULL_ARG</td><td>If <code>p_page_addr</code> is NULL. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_ARG</td><td>If <code>num_pages</code> is zero. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_ADDR</td><td>If the operation would go beyond the flash memory boundaries specified in <code>p_config</code>. </td></tr>
    <tr><td class="paramname">FS_ERR_UNALIGNED_ADDR</td><td>If <code>p_page_addr</code> is not aligned to a page boundary. </td></tr>
    <tr><td class="paramname">FS_ERR_QUEUE_FULL</td><td>If the internal operation queue is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26dabfb4f9594822d7762803caa932d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> fs_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the module. </p>
<p>This functions assigns pages in flash according to all registered configurations.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FS_SUCCESS</td><td>If the module was successfully initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5b0b759ae47b1a89ab23a03a1c570e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fs_queue_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the queue for flash operations is empty. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the queue is empty. </td></tr>
    <tr><td class="paramname">false</td><td>If there are flash operations in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae37b0b1b485f017f8599d6f2ffda2821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fs_queue_is_full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the queue for flash operations is full. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the queue is full. </td></tr>
    <tr><td class="paramname">false</td><td>If there is space for more operations in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30139880a5d7d80dfc877840ce71c1a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> fs_queued_op_count_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_op_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the number of queued flash operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_op_count</td><td>The number of queued flash operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FS_SUCCESS</td><td>If the number of queued operations was retrieved successfully. </td></tr>
    <tr><td class="paramname">FS_ERR_NULL_ARG</td><td>If <code>p_op_count</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf94976860d509d5c8d28c6d3bbb9a059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__fstorage.html#ga7d7c3e91fa4f4614eaf115069db12374">fs_ret_t</a> fs_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfs__config__t.html">fs_config_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length_words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for storing data in flash. </p>
<p>Copies <code>length_words</code> words from <code>p_src</code> to the location pointed by <code>p_dest</code>. If the length of the data exceeds <a class="el" href="group__fstorage__config.html#ga622bd14fcc3353d8bccb6d8573573b72">FS_MAX_WRITE_SIZE_WORDS</a>, the data will be written down in several chunks, as necessary. Only one event will be sent to the application upon completion. Both the source and the destination of the data must be word aligned. This function is asynchronous, completion is reported via an event sent the the callback function specified in the supplied configuration.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data to be written to flash has to be kept in memory until the operation has terminated, i.e., an event is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>fstorage configuration registered by the application. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>The address in flash memory where to store the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to the data to store in flash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length_words</td><td>Length of the data to store, in words. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>User-defined context passed to the interrupt handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_CFG</td><td>If <code>p_config</code> is NULL or contains invalid data. </td></tr>
    <tr><td class="paramname">FS_ERR_NULL_ARG</td><td>If <code>p_dest</code> or <code>p_src</code> are NULL. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_ARG</td><td>If <code>length_words</code> is zero. </td></tr>
    <tr><td class="paramname">FS_ERR_INVALID_ADDR</td><td>If <code>p_dest</code> or <code>p_src</code> are outside of the flash memory boundaries specified in <code>p_config</code>. </td></tr>
    <tr><td class="paramname">FS_ERR_UNALIGNED_ADDR</td><td>If <code>p_dest</code> or <code>p_src</code> are not aligned to a word boundary. </td></tr>
    <tr><td class="paramname">FS_ERR_QUEUE_FULL</td><td>If the internal operation queue is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fcde5d157fe6048ca55c0ff3d403f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fs_sys_event_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sys_evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for handling system events from the SoftDevice. </p>
<p>If any of the modules used by the application rely on fstorage, the application should dispatch system events to fstorage using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_evt</td><td>System event from the SoftDevice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri Mar 10 2017" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
