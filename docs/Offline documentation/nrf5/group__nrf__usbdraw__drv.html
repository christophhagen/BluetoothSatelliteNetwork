<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v13.0.0: USB Device raw IP driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v13.0.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<!--<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>-->
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s132","s140","s212","s332"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nrf__usbdraw__drv.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Device raw IP driver<div class="ingroups"><a class="el" href="group__nrf__drv__usbd.html">USB Device raw IP HAL and driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><span class="whichnRF nRF52840">nRF52840 only:</span> USB Device raw IP driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event structure.  <a href="structnrf__drv__usbd__evt__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionnrf__drv__usbd__data__ptr__t.html">nrf_drv_usbd_data_ptr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal data pointer.  <a href="unionnrf__drv__usbd__data__ptr__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to be filled with information about the next transfer.  <a href="structnrf__drv__usbd__ep__transfer__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total transfer configuration.  <a href="structnrf__drv__usbd__transfer__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionnrf__drv__usbd__handler__t.html">nrf_drv_usbd_handler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal transfer handler.  <a href="unionnrf__drv__usbd__handler__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer descriptor.  <a href="structnrf__drv__usbd__handler__desc__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup packet structure.  <a href="structnrf__drv__usbd__setup__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes in the endpoint.  <a href="#ga3ecfa2bc5ba0c2b9c7cd384290f27739">More...</a><br/></td></tr>
<tr class="separator:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga2482239c2133ddfe1fd269f8d2c44f6c">NRF_DRV_USBD_ISOSIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes for isochronous endpoints.  <a href="#ga2482239c2133ddfe1fd269f8d2c44f6c">More...</a><br/></td></tr>
<tr class="separator:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gab4bbed2bd99a3c54cc5956f16b72061c">NRF_DRV_USBD_FEEDER_BUFFER_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a></td></tr>
<tr class="memdesc:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of internal feeder buffer.  <a href="#gab4bbed2bd99a3c54cc5956f16b72061c">More...</a><br/></td></tr>
<tr class="separator:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name, tx_buff, tx_size, tx_flags)</td></tr>
<tr class="memdesc:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary macro for declaring IN transfer description with flags.  <a href="#ga1ee0dbca6acc4af77ccbb555b2f109d3">More...</a><br/></td></tr>
<tr class="separator:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad153e248ce252afaa4a3a3912e41d547"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gad153e248ce252afaa4a3a3912e41d547">NRF_DRV_USBD_TRANSFER_IN</a>(name, tx_buff, tx_size)&#160;&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name, tx_buff, tx_size, 0)</td></tr>
<tr class="memdesc:gad153e248ce252afaa4a3a3912e41d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring IN transfer description.  <a href="#gad153e248ce252afaa4a3a3912e41d547">More...</a><br/></td></tr>
<tr class="separator:gad153e248ce252afaa4a3a3912e41d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec2fac985fd7d5b96629028d558796e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga9ec2fac985fd7d5b96629028d558796e">NRF_DRV_USBD_TRANSFER_IN_ZLP</a>(name, tx_buff, tx_size)</td></tr>
<tr class="memdesc:ga9ec2fac985fd7d5b96629028d558796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring IN transfer description.  <a href="#ga9ec2fac985fd7d5b96629028d558796e">More...</a><br/></td></tr>
<tr class="separator:ga9ec2fac985fd7d5b96629028d558796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga6c757e4582e52975bb6dabd8f0dc1e0f">NRF_DRV_USBD_TRANSFER_OUT</a>(name, rx_buff, rx_size)</td></tr>
<tr class="memdesc:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring OUT transfer item (<a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a>)  <a href="#ga6c757e4582e52975bb6dabd8f0dc1e0f">More...</a><br/></td></tr>
<tr class="separator:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5817eb96a762eea1263f4a39924ae411"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga5817eb96a762eea1263f4a39924ae411">nrf_drv_usbd_event_handler_t</a> )(<a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:ga5817eb96a762eea1263f4a39924ae411"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD event callback function type.  <a href="#ga5817eb96a762eea1263f4a39924ae411">More...</a><br/></td></tr>
<tr class="separator:ga5817eb96a762eea1263f4a39924ae411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1052a944ba028d70b17c50ac549689"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga5c1052a944ba028d70b17c50ac549689">nrf_drv_usbd_feeder_t</a> )(<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size)</td></tr>
<tr class="memdesc:ga5c1052a944ba028d70b17c50ac549689"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer feeder.  <a href="#ga5c1052a944ba028d70b17c50ac549689">More...</a><br/></td></tr>
<tr class="separator:ga5c1052a944ba028d70b17c50ac549689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522b26ee0224d93697dfcb7cf3bc53d5"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga522b26ee0224d93697dfcb7cf3bc53d5">nrf_drv_usbd_consumer_t</a> )(<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size, size_t data_size)</td></tr>
<tr class="memdesc:ga522b26ee0224d93697dfcb7cf3bc53d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer consumer.  <a href="#ga522b26ee0224d93697dfcb7cf3bc53d5">More...</a><br/></td></tr>
<tr class="separator:ga522b26ee0224d93697dfcb7cf3bc53d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaa65ebeb12443fd8325e7447a2187f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70afb5b50c3d9680fbda0b08830f42e382f">NRF_DRV_USBD_EPOUT0</a> = NRF_USBD_EPOUT(0), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a0806d24dac06f5c0d3898cd67e405617">NRF_DRV_USBD_EPOUT1</a> = NRF_USBD_EPOUT(1), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70aaf42aef784c75192853fddefe57a2fb9">NRF_DRV_USBD_EPOUT2</a> = NRF_USBD_EPOUT(2), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a7ebbfa51beb7a0dd6ee5f071b8d35950">NRF_DRV_USBD_EPOUT3</a> = NRF_USBD_EPOUT(3), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70ad4a07134f5ea54e003d4a17ee1ba4c7f">NRF_DRV_USBD_EPOUT4</a> = NRF_USBD_EPOUT(4), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a5ab577a8042f3f0f73ad3de23b0d4ba3">NRF_DRV_USBD_EPOUT5</a> = NRF_USBD_EPOUT(5), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a6da7bf30befbefaaf7f8ad79c9f1666a">NRF_DRV_USBD_EPOUT6</a> = NRF_USBD_EPOUT(6), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70af087b27308b6f18bf4bf8fff43d827f5">NRF_DRV_USBD_EPOUT7</a> = NRF_USBD_EPOUT(7), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70ae53cb7398e739532f7069f4859a2d2c5">NRF_DRV_USBD_EPOUT8</a> = NRF_USBD_EPOUT(8), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70ac8e5ae481bf8a23aa2e5f9e4d9bfec24">NRF_DRV_USBD_EPIN0</a> = NRF_USBD_EPIN(0), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a78c594d15eee745ac6eb11e83c294b1b">NRF_DRV_USBD_EPIN1</a> = NRF_USBD_EPIN(1), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70acb4347afc5cebf8dc2cf6efe6825eed0">NRF_DRV_USBD_EPIN2</a> = NRF_USBD_EPIN(2), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70acd14758cfae4cca0095c7ced300fc678">NRF_DRV_USBD_EPIN3</a> = NRF_USBD_EPIN(3), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a8609bbebe798a8ae69309b586c83c922">NRF_DRV_USBD_EPIN4</a> = NRF_USBD_EPIN(4), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a69321276f3de8b259f82bf3720274662">NRF_DRV_USBD_EPIN5</a> = NRF_USBD_EPIN(5), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70aaf4e021d052ef571afbf3d2f140ba3c1">NRF_DRV_USBD_EPIN6</a> = NRF_USBD_EPIN(6), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a4d9d5809cd17a2bb686b6b896ea3a446">NRF_DRV_USBD_EPIN7</a> = NRF_USBD_EPIN(7), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggaaa65ebeb12443fd8325e7447a2187f70a51de27329e5d1c525409b0d073d661c4">NRF_DRV_USBD_EPIN8</a> = NRF_USBD_EPIN(8)
<br/>
 }</td></tr>
<tr class="memdesc:gaaa65ebeb12443fd8325e7447a2187f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint identifier.  <a href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">More...</a><br/></td></tr>
<tr class="separator:gaaa65ebeb12443fd8325e7447a2187f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga9f0b03e5a41539896e07ccba22b67b3d">nrf_drv_usbd_event_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3da5e5aa0126cace9c3e1ca9bf202fcfb76">NRF_DRV_USBD_EVT_SOF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3dafb97ef9016ced03034a496683b9d59ef">NRF_DRV_USBD_EVT_RESET</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3da610d9052eed8b8fa98d6d66a9b4cfd78">NRF_DRV_USBD_EVT_SUSPEND</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3da773b2df8b85d14aae8e75b85dc75be32">NRF_DRV_USBD_EVT_RESUME</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3dad5eb9fc5f0621fa680cab1ccb8a6911d">NRF_DRV_USBD_EVT_SETUP</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3da76a716e60a05c83622c79910a404fd92">NRF_DRV_USBD_EVT_CNT</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Events generated by the library.  <a href="group__nrf__usbdraw__drv.html#ga9f0b03e5a41539896e07ccba22b67b3d">More...</a><br/></td></tr>
<tr class="separator:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51235955b1bec1393a393946544fc6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gae51235955b1bec1393a393946544fc6e">nrf_drv_usbd_ep_status_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggae51235955b1bec1393a393946544fc6ea6c64dda31a6dd80d690a078bbb713f05">NRF_USBD_EP_OK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggae51235955b1bec1393a393946544fc6ea82b67485a8aed419a744bbac8c5de806">NRF_USBD_EP_WAITING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggae51235955b1bec1393a393946544fc6ea32ddfa8d69d4f14816f5fe83fb2713fc">NRF_USBD_EP_OVERLOAD</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ggae51235955b1bec1393a393946544fc6ea184bf8a573eaa257384917103ae0fd9b">NRF_USBD_EP_ABORTED</a>
<br/>
 }</td></tr>
<tr class="memdesc:gae51235955b1bec1393a393946544fc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible endpoint error codes.  <a href="group__nrf__usbdraw__drv.html#gae51235955b1bec1393a393946544fc6e">More...</a><br/></td></tr>
<tr class="separator:gae51235955b1bec1393a393946544fc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe244baf5655539aa3e356620f2acfc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a> { <a class="el" href="group__nrf__usbdraw__drv.html#ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3">NRF_DRV_USBD_TRANSFER_ZLP_FLAG</a> = 1U &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:gacfe244baf5655539aa3e356620f2acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for the current transfer.  <a href="group__nrf__usbdraw__drv.html#gacfe244baf5655539aa3e356620f2acfc">More...</a><br/></td></tr>
<tr class="separator:gacfe244baf5655539aa3e356620f2acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf8b527764aefdbe4859981c56f96dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gabf8b527764aefdbe4859981c56f96dd5">nrf_drv_usbd_init</a> (<a class="el" href="group__nrf__usbdraw__drv.html#ga5817eb96a762eea1263f4a39924ae411">nrf_drv_usbd_event_handler_t</a> const event_handler)</td></tr>
<tr class="memdesc:gabf8b527764aefdbe4859981c56f96dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library initialization.  <a href="#gabf8b527764aefdbe4859981c56f96dd5">More...</a><br/></td></tr>
<tr class="separator:gabf8b527764aefdbe4859981c56f96dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07274745cf2ca5867c1c50192aadaa43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07274745cf2ca5867c1c50192aadaa43"></a>
<a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga07274745cf2ca5867c1c50192aadaa43">nrf_drv_usbd_uninit</a> (void)</td></tr>
<tr class="memdesc:ga07274745cf2ca5867c1c50192aadaa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library deinitialization. <br/></td></tr>
<tr class="separator:ga07274745cf2ca5867c1c50192aadaa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee8557590430bd5d50d64b9363ecc7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gafee8557590430bd5d50d64b9363ecc7d">nrf_drv_usbd_enable</a> (void)</td></tr>
<tr class="memdesc:gafee8557590430bd5d50d64b9363ecc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the USBD port.  <a href="#gafee8557590430bd5d50d64b9363ecc7d">More...</a><br/></td></tr>
<tr class="separator:gafee8557590430bd5d50d64b9363ecc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gaad4f73e18396c94c6c6a90114ad3de6a">nrf_drv_usbd_disable</a> (void)</td></tr>
<tr class="memdesc:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the USBD port.  <a href="#gaad4f73e18396c94c6c6a90114ad3de6a">More...</a><br/></td></tr>
<tr class="separator:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb757b8af8c827b45e306cfbd2d38045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a> (bool enable_sof)</td></tr>
<tr class="memdesc:gacb757b8af8c827b45e306cfbd2d38045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start USB functionality.  <a href="#gacb757b8af8c827b45e306cfbd2d38045">More...</a><br/></td></tr>
<tr class="separator:gacb757b8af8c827b45e306cfbd2d38045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga1ad60ee9a55f2be757f63b83ec7e45ce">nrf_drv_usbd_stop</a> (void)</td></tr>
<tr class="memdesc:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB functionality.  <a href="#ga1ad60ee9a55f2be757f63b83ec7e45ce">More...</a><br/></td></tr>
<tr class="separator:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga3ecb8a9633445fd9e2eb79f956e69361">nrf_drv_usbd_is_initialized</a> (void)</td></tr>
<tr class="memdesc:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is initialized.  <a href="#ga3ecb8a9633445fd9e2eb79f956e69361">More...</a><br/></td></tr>
<tr class="separator:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2723c73382ccd1db168d6e79d53e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gafb2723c73382ccd1db168d6e79d53e47">nrf_drv_usbd_is_enabled</a> (void)</td></tr>
<tr class="memdesc:gafb2723c73382ccd1db168d6e79d53e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is enabled.  <a href="#gafb2723c73382ccd1db168d6e79d53e47">More...</a><br/></td></tr>
<tr class="separator:gafb2723c73382ccd1db168d6e79d53e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga77db8d2bb83b5d393bd7b179f065fac6">nrf_drv_usbd_is_started</a> (void)</td></tr>
<tr class="memdesc:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is started.  <a href="#ga77db8d2bb83b5d393bd7b179f065fac6">More...</a><br/></td></tr>
<tr class="separator:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga2cea23d18bfb29af3b36aa53b32fca14">nrf_drv_usbd_ep_max_packet_size_set</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, uint16_t size)</td></tr>
<tr class="memdesc:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure packet size that should be supported by the endpoint.  <a href="#ga2cea23d18bfb29af3b36aa53b32fca14">More...</a><br/></td></tr>
<tr class="separator:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga693c13c49ab1fbe7ffa42386de8a15af">nrf_drv_usbd_ep_max_packet_size_get</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configured endpoint packet size.  <a href="#ga693c13c49ab1fbe7ffa42386de8a15af">More...</a><br/></td></tr>
<tr class="separator:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gacd74bb1091ba7fb9a710ef98caf04df3">nrf_drv_usbd_ep_enable_check</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the selected endpoint is enabled.  <a href="#gacd74bb1091ba7fb9a710ef98caf04df3">More...</a><br/></td></tr>
<tr class="separator:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga4dd2c52f807f3663cc864f358fd53ac6">nrf_drv_usbd_ep_enable</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable selected endpoint.  <a href="#ga4dd2c52f807f3663cc864f358fd53ac6">More...</a><br/></td></tr>
<tr class="separator:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedb19d74504654d1628e0e3ca4976ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gacedb19d74504654d1628e0e3ca4976ba">nrf_drv_usbd_ep_disable</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gacedb19d74504654d1628e0e3ca4976ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable selected endpoint.  <a href="#gacedb19d74504654d1628e0e3ca4976ba">More...</a><br/></td></tr>
<tr class="separator:gacedb19d74504654d1628e0e3ca4976ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfed547bace8fe28d0142ad1af18a008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> const *const p_transfer)</td></tr>
<tr class="memdesc:gabfed547bace8fe28d0142ad1af18a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start sending data over endpoint.  <a href="#gabfed547bace8fe28d0142ad1af18a008">More...</a><br/></td></tr>
<tr class="separator:gabfed547bace8fe28d0142ad1af18a008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1219e767791807d91d92871e95346f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga1219e767791807d91d92871e95346f91">nrf_drv_usbd_ep_handled_transfer</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a> const *const p_handler)</td></tr>
<tr class="memdesc:ga1219e767791807d91d92871e95346f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start sending data over the endpoint using the transfer handler function.  <a href="#ga1219e767791807d91d92871e95346f91">More...</a><br/></td></tr>
<tr class="separator:ga1219e767791807d91d92871e95346f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gad844c7b3654777b8e3a2c8d0b5657d26">nrf_drv_usbd_feeder_buffer_get</a> (void)</td></tr>
<tr class="memdesc:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temporary buffer to be used by the feeder.  <a href="#gad844c7b3654777b8e3a2c8d0b5657d26">More...</a><br/></td></tr>
<tr class="separator:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga5d3467a64cb0eba21868aa9a1e96f0d4">nrf_drv_usbd_ep_status_get</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, size_t *p_size)</td></tr>
<tr class="memdesc:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about last finished or current transfer.  <a href="#ga5d3467a64cb0eba21868aa9a1e96f0d4">More...</a><br/></td></tr>
<tr class="separator:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3a71a437745665c288110fdb0356b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gada3a71a437745665c288110fdb0356b8">nrf_drv_usbd_epout_size_get</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gada3a71a437745665c288110fdb0356b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of received bytes.  <a href="#gada3a71a437745665c288110fdb0356b8">More...</a><br/></td></tr>
<tr class="separator:gada3a71a437745665c288110fdb0356b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73852623b474a7626496366089cb1d85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga73852623b474a7626496366089cb1d85">nrf_drv_usbd_ep_is_busy</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga73852623b474a7626496366089cb1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if endpoint buffer is ready or is under USB IP control.  <a href="#ga73852623b474a7626496366089cb1d85">More...</a><br/></td></tr>
<tr class="separator:ga73852623b474a7626496366089cb1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ca226d86703aad748af44ca24dd819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga51ca226d86703aad748af44ca24dd819">nrf_drv_usbd_ep_stall</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga51ca226d86703aad748af44ca24dd819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall endpoint.  <a href="#ga51ca226d86703aad748af44ca24dd819">More...</a><br/></td></tr>
<tr class="separator:ga51ca226d86703aad748af44ca24dd819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga58141094e1a11a5b0e91e4a3b0f02784">nrf_drv_usbd_ep_stall_clear</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stall flag on endpoint.  <a href="#ga58141094e1a11a5b0e91e4a3b0f02784">More...</a><br/></td></tr>
<tr class="separator:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gaca00e5defeb5986340ecd0e7e9c364b9">nrf_drv_usbd_ep_stall_check</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if endpoint is stalled.  <a href="#gaca00e5defeb5986340ecd0e7e9c364b9">More...</a><br/></td></tr>
<tr class="separator:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47e5d114e751ae88feee568a7dda845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gae47e5d114e751ae88feee568a7dda845">nrf_drv_usbd_setup_get</a> (<a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a> *const p_setup)</td></tr>
<tr class="memdesc:gae47e5d114e751ae88feee568a7dda845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parsed setup data.  <a href="#gae47e5d114e751ae88feee568a7dda845">More...</a><br/></td></tr>
<tr class="separator:gae47e5d114e751ae88feee568a7dda845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a84106ecef4effd20d615fb985ecb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gac6a84106ecef4effd20d615fb985ecb8">nrf_drv_usbd_setup_data_clear</a> (void)</td></tr>
<tr class="memdesc:gac6a84106ecef4effd20d615fb985ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear only for data transmission on setup endpoint.  <a href="#gac6a84106ecef4effd20d615fb985ecb8">More...</a><br/></td></tr>
<tr class="separator:gac6a84106ecef4effd20d615fb985ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gaa8aa78cfbacee0edfc5f43d184aaaddc">nrf_drv_usbd_setup_clear</a> (void)</td></tr>
<tr class="memdesc:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear setup endpoint.  <a href="#gaa8aa78cfbacee0edfc5f43d184aaaddc">More...</a><br/></td></tr>
<tr class="separator:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680eae1b344512f9e7c166a740bfa5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga680eae1b344512f9e7c166a740bfa5ba">nrf_drv_usbd_setup_stall</a> (void)</td></tr>
<tr class="memdesc:ga680eae1b344512f9e7c166a740bfa5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall setup endpoint.  <a href="#ga680eae1b344512f9e7c166a740bfa5ba">More...</a><br/></td></tr>
<tr class="separator:ga680eae1b344512f9e7c166a740bfa5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada87d3dd94488b499ce4b1d3f99b486d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#gada87d3dd94488b499ce4b1d3f99b486d">usbd_drv_ep_abort</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="separator:gada87d3dd94488b499ce4b1d3f99b486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569381189170f7bbce7995894bcfaa87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga569381189170f7bbce7995894bcfaa87">nrf_drv_usbd_last_setup_dir_get</a> (void)</td></tr>
<tr class="memdesc:ga569381189170f7bbce7995894bcfaa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about expected transfer SETUP data direction.  <a href="#ga569381189170f7bbce7995894bcfaa87">More...</a><br/></td></tr>
<tr class="separator:ga569381189170f7bbce7995894bcfaa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga52acb0c56ab24137f5e6d45f47e46a46">nrf_drv_usbd_transfer_out_drop</a> (<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop transfer on OUT endpoint.  <a href="#ga52acb0c56ab24137f5e6d45f47e46a46">More...</a><br/></td></tr>
<tr class="separator:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Possible schemes of DMA scheduling</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4e633a446652c354dfa1e304ff6a6376"></a>Definition of available configuration constants used by DMA scheduler </p>
</td></tr>
<tr class="memitem:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga7a7a7bbf6ff89a856f8d6b33633d8158">NRF_DRV_USBD_DMASCHEDULER_PRIORITIZED</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highly prioritized access.  <a href="#ga7a7a7bbf6ff89a856f8d6b33633d8158">More...</a><br/></td></tr>
<tr class="separator:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga8e6a3d41b494e34b66fb320ae3a0634d">NRF_DRV_USBD_DMASCHEDULER_ROUNDROBIN</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round robin scheme.  <a href="#ga8e6a3d41b494e34b66fb320ae3a0634d">More...</a><br/></td></tr>
<tr class="separator:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Macros for creating endpoint identifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1b3261fef70bc87900134bbc77e61aae"></a>Auxiliary macros to be used to create Endpoint identifier that is compatible with USB specification. </p>
</td></tr>
<tr class="memitem:ga22655b77192f6b0b4acd570a15d1e13e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga22655b77192f6b0b4acd570a15d1e13e">NRF_DRV_USBD_EPIN</a>(n)&#160;&#160;&#160;((<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga9be1e5cf3c38d21e1116c2771ab86bcf">NRF_USBD_EPIN</a>(n))</td></tr>
<tr class="memdesc:ga22655b77192f6b0b4acd570a15d1e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create identifier for IN endpoint.  <a href="#ga22655b77192f6b0b4acd570a15d1e13e">More...</a><br/></td></tr>
<tr class="separator:ga22655b77192f6b0b4acd570a15d1e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbdraw__drv.html#ga74bb0cb3e39e40aed5797256fcd62e3d">NRF_DRV_USBD_EPOUT</a>(n)&#160;&#160;&#160;((<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga8b6d96a8d69d5283919896d6f5b54b01">NRF_USBD_EPOUT</a>(n))</td></tr>
<tr class="memdesc:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create identifier for OUT endpoint.  <a href="#ga74bb0cb3e39e40aed5797256fcd62e3d">More...</a><br/></td></tr>
<tr class="separator:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><span class="whichnRF nRF52840">nRF52840 only:</span> USB Device raw IP driver. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7a7a7bbf6ff89a856f8d6b33633d8158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_DMASCHEDULER_PRIORITIZED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highly prioritized access. </p>
<p>Endpoint with lower number has always higher priority and its data would be transfered first. OUT endpoints ale processed before IN endpoints </p>

</div>
</div>
<a class="anchor" id="ga8e6a3d41b494e34b66fb320ae3a0634d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_DMASCHEDULER_ROUNDROBIN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round robin scheme. </p>
<p>All endpoints are processed in round-robin scheme. It means that when one endpoint is processed next in order would be the nearest with lower number. When no endpoints with lower number requires processing - then all endpoints from 0 are tested. </p>

</div>
</div>
<a class="anchor" id="ga22655b77192f6b0b4acd570a15d1e13e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga9be1e5cf3c38d21e1116c2771ab86bcf">NRF_USBD_EPIN</a>(n))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create identifier for IN endpoint. </p>
<p>Simple macro to create IN endpoint identifier for given endpoint number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint identifier that connects endpoint number and endpoint direction. </dd></dl>

</div>
</div>
<a class="anchor" id="ga74bb0cb3e39e40aed5797256fcd62e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPOUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga8b6d96a8d69d5283919896d6f5b54b01">NRF_USBD_EPOUT</a>(n))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create identifier for OUT endpoint. </p>
<p>Simple macro to create OUT endpoint identifier for given endpoint number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint identifier that connects endpoint number and endpoint direction. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ecfa2bc5ba0c2b9c7cd384290f27739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPSIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes in the endpoint. </p>
<p>Constant that informs about endpoint size </p>

</div>
</div>
<a class="anchor" id="gab4bbed2bd99a3c54cc5956f16b72061c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_FEEDER_BUFFER_SIZE&#160;&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of internal feeder buffer. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbdraw__drv.html#gad844c7b3654777b8e3a2c8d0b5657d26" title="Get the temporary buffer to be used by the feeder.">nrf_drv_usbd_feeder_buffer_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2482239c2133ddfe1fd269f8d2c44f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_ISOSIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes for isochronous endpoints. </p>
<p>Number of bytes for isochronous endpoints in total. This number would be shared between IN and OUT endpoint. It may be also assigned totaly to one endpoint. </p>
<dl class="section see"><dt>See Also</dt><dd>nrf_usbd_isosplit_set </dd>
<dd>
nrf_usbd_isosplit_get </dd></dl>

</div>
</div>
<a class="anchor" id="gad153e248ce252afaa4a3a3912e41d547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__nrf__usbdraw__drv.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name, tx_buff, tx_size, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for declaring IN transfer description. </p>
<p>Normal transfer mode, no ZLP would be automatically generated.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> </dd>
<dd>
<a class="el" href="group__nrf__usbdraw__drv.html#ga9ec2fac985fd7d5b96629028d558796e" title="Helper macro for declaring IN transfer description.">NRF_DRV_USBD_TRANSFER_IN_ZLP</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ee0dbca6acc4af77ccbb555b2f109d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN_FLAGS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> name = {                               \</div>
<div class="line">       .<a class="code" href="structnrf__drv__usbd__transfer__t.html#a92f55a088638ea71a83953052473a99d" title="Union with available data pointers used by the library.">p_data</a> = { .<a class="code" href="unionnrf__drv__usbd__data__ptr__t.html#a95cfddb4da8b0f488001d0297251f9cb" title="Constant TX buffer pointer.">tx</a> = (tx_buff)  },                                   \</div>
<div class="line">       .size = (tx_size),                                                \</div>
<div class="line">       .flags = (tx_flags)                                               \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Auxiliary macro for declaring IN transfer description with flags. </p>
<p>The base macro for creating transfers with any configuration option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name. </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer. </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size. </td></tr>
    <tr><td class="paramname">tx_flags</td><td>Flags for the transfer (see <a class="el" href="group__nrf__usbdraw__drv.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ec2fac985fd7d5b96629028d558796e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN_ZLP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__nrf__usbdraw__drv.html#ga1ee0dbca6acc4af77ccbb555b2f109d3" title="Auxiliary macro for declaring IN transfer description with flags.">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(                          \</div>
<div class="line">        name,                                                \</div>
<div class="line">        tx_buff,                                             \</div>
<div class="line">        tx_size,                                             \</div>
<div class="line">        <a class="code" href="group__nrf__usbdraw__drv.html#ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3" title="Add a zero-length packet.">NRF_DRV_USBD_TRANSFER_ZLP_FLAG</a>)</div>
</div><!-- fragment -->
<p>Helper macro for declaring IN transfer description. </p>
<p>ZLP mode - Zero Length Packet would be generated on the end of the transfer (always!).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> </dd>
<dd>
<a class="el" href="group__nrf__usbdraw__drv.html#gad153e248ce252afaa4a3a3912e41d547" title="Helper macro for declaring IN transfer description.">NRF_DRV_USBD_TRANSFER_IN</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c757e4582e52975bb6dabd8f0dc1e0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_OUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> name = {                      \</div>
<div class="line">       .<a class="code" href="structnrf__drv__usbd__transfer__t.html#a92f55a088638ea71a83953052473a99d" title="Union with available data pointers used by the library.">p_data</a> = { .<a class="code" href="unionnrf__drv__usbd__data__ptr__t.html#a775158207650c02089f34179c8ccd9ab" title="Writable RX buffer pointer.">rx</a> = (rx_buff)  },                          \</div>
<div class="line">       .size = (rx_size),                                       \</div>
<div class="line">       .flags = 0                                               \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Helper macro for declaring OUT transfer item (<a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">rx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">rx_size</td><td>Transfer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga522b26ee0224d93697dfcb7cf3bc53d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* nrf_drv_usbd_consumer_t)(<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size, size_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD transfer consumer. </p>
<p>Pointer for a transfer consumer. Transfer consumer is a feedback function used to prepare a single RX (Host-&gt;Device) endpoint transfer.</p>
<p>The transfer must provide a buffer big enough to fit the whole data from the endpoint. Otherwise, the NRF_USBD_EP_OVERLOAD event is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_next</td><td>Structure with the data for the next transfer to be filled. Required only if the function returns true. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_context</td><td>Context variable configured with the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_size</td><td>The endpoint size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of received bytes in the endpoint buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Current transfer is the last one - you do not need to call the function again. </td></tr>
    <tr><td class="paramname">true</td><td>There is more data to be prepared and when current transfer finishes, the feeder function is expected to be called again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5817eb96a762eea1263f4a39924ae411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrf_drv_usbd_event_handler_t)(<a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a> const *const p_event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD event callback function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event information structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c1052a944ba028d70b17c50ac549689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* nrf_drv_usbd_feeder_t)(<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD transfer feeder. </p>
<p>Pointer for a transfer feeder. Transfer feeder is a feedback function used to prepare a single TX (Device-&gt;Host) endpoint transfer.</p>
<p>The transfers provided by the feeder must be simple:</p>
<ul>
<li>The size of the transfer provided by this function is limited to a single endpoint buffer. Bigger transfers are not handled automatically in this case.</li>
<li>Flash transfers are not automatically supported- you must copy them to the RAM buffer before.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function may use <a class="el" href="group__nrf__usbdraw__drv.html#gad844c7b3654777b8e3a2c8d0b5657d26">nrf_drv_usbd_feeder_buffer_get</a> to gain a temporary buffer that can be used to prepare transfer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_next</td><td>Structure with the data for the next transfer to be filled. Required only if the function returns true. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_context</td><td>Context variable configured with the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_size</td><td>The endpoint size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The current transfer is the last one - you do not need to call the function again. </td></tr>
    <tr><td class="paramname">true</td><td>There is more data to be prepared and when the current transfer finishes, the feeder function is expected to be called again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae51235955b1bec1393a393946544fc6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbdraw__drv.html#gae51235955b1bec1393a393946544fc6e">nrf_drv_usbd_ep_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible endpoint error codes. </p>
<p>Error codes that may be returned with <a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae51235955b1bec1393a393946544fc6ea6c64dda31a6dd80d690a078bbb713f05"></a>NRF_USBD_EP_OK</em>&nbsp;</td><td class="fielddoc">
<p>No error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae51235955b1bec1393a393946544fc6ea82b67485a8aed419a744bbac8c5de806"></a>NRF_USBD_EP_WAITING</em>&nbsp;</td><td class="fielddoc">
<p>Data received, no buffer prepared already - waiting for configured transfer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae51235955b1bec1393a393946544fc6ea32ddfa8d69d4f14816f5fe83fb2713fc"></a>NRF_USBD_EP_OVERLOAD</em>&nbsp;</td><td class="fielddoc">
<p>Received number of bytes cannot fit given buffer This error would also be returned when next_transfer function has been defined but currently received data cannot fit completely in current buffer. No data split from single endpoint transmission is supported.</p>
<p>When this error is reported - data is left inside endpoint buffer. Clear endpoint or prepare new buffer and read it. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae51235955b1bec1393a393946544fc6ea184bf8a573eaa257384917103ae0fd9b"></a>NRF_USBD_EP_ABORTED</em>&nbsp;</td><td class="fielddoc">
<p>EP0 transfer can be aborted when new setup comes. Any other transfer can be aborted by USB reset or library stopping. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaaa65ebeb12443fd8325e7447a2187f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint identifier. </p>
<p>Endpoint identifier used in the driver. This endpoint number is consistent with USB 2.0 specification. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70afb5b50c3d9680fbda0b08830f42e382f"></a>NRF_DRV_USBD_EPOUT0</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 0 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a0806d24dac06f5c0d3898cd67e405617"></a>NRF_DRV_USBD_EPOUT1</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 1 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70aaf42aef784c75192853fddefe57a2fb9"></a>NRF_DRV_USBD_EPOUT2</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 2 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a7ebbfa51beb7a0dd6ee5f071b8d35950"></a>NRF_DRV_USBD_EPOUT3</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 3 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70ad4a07134f5ea54e003d4a17ee1ba4c7f"></a>NRF_DRV_USBD_EPOUT4</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 4 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a5ab577a8042f3f0f73ad3de23b0d4ba3"></a>NRF_DRV_USBD_EPOUT5</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 5 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a6da7bf30befbefaaf7f8ad79c9f1666a"></a>NRF_DRV_USBD_EPOUT6</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 6 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70af087b27308b6f18bf4bf8fff43d827f5"></a>NRF_DRV_USBD_EPOUT7</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 7 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70ae53cb7398e739532f7069f4859a2d2c5"></a>NRF_DRV_USBD_EPOUT8</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint OUT 8 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70ac8e5ae481bf8a23aa2e5f9e4d9bfec24"></a>NRF_DRV_USBD_EPIN0</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 0 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a78c594d15eee745ac6eb11e83c294b1b"></a>NRF_DRV_USBD_EPIN1</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 1 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70acb4347afc5cebf8dc2cf6efe6825eed0"></a>NRF_DRV_USBD_EPIN2</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 2 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70acd14758cfae4cca0095c7ced300fc678"></a>NRF_DRV_USBD_EPIN3</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 3 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a8609bbebe798a8ae69309b586c83c922"></a>NRF_DRV_USBD_EPIN4</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 4 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a69321276f3de8b259f82bf3720274662"></a>NRF_DRV_USBD_EPIN5</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 5 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70aaf4e021d052ef571afbf3d2f140ba3c1"></a>NRF_DRV_USBD_EPIN6</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 6 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a4d9d5809cd17a2bb686b6b896ea3a446"></a>NRF_DRV_USBD_EPIN7</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 7 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaa65ebeb12443fd8325e7447a2187f70a51de27329e5d1c525409b0d073d661c4"></a>NRF_DRV_USBD_EPIN8</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint IN 8 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9f0b03e5a41539896e07ccba22b67b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbdraw__drv.html#ga9f0b03e5a41539896e07ccba22b67b3d">nrf_drv_usbd_event_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Events generated by the library. </p>
<p>Enumeration of possible events that may be generated by the library. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3da5e5aa0126cace9c3e1ca9bf202fcfb76"></a>NRF_DRV_USBD_EVT_SOF</em>&nbsp;</td><td class="fielddoc">
<p>Start Of Frame event on USB bus detected </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3dafb97ef9016ced03034a496683b9d59ef"></a>NRF_DRV_USBD_EVT_RESET</em>&nbsp;</td><td class="fielddoc">
<p>Reset condition on USB bus detected </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3da610d9052eed8b8fa98d6d66a9b4cfd78"></a>NRF_DRV_USBD_EVT_SUSPEND</em>&nbsp;</td><td class="fielddoc">
<p>This device should go to suspend mode now </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3da773b2df8b85d14aae8e75b85dc75be32"></a>NRF_DRV_USBD_EVT_RESUME</em>&nbsp;</td><td class="fielddoc">
<p>This device should resume from suspend now </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3dad5eb9fc5f0621fa680cab1ccb8a6911d"></a>NRF_DRV_USBD_EVT_SETUP</em>&nbsp;</td><td class="fielddoc">
<p>Setup frame received and decoded </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df"></a>NRF_DRV_USBD_EVT_EPTRANSFER</em>&nbsp;</td><td class="fielddoc">
<p>For Rx (OUT: Host-&gt;Device):</p>
<ol type="1">
<li>The packet has been received but there is no buffer prepared for transfer already.</li>
<li>Whole transfer has been finished</li>
</ol>
<p>For Tx (IN: Device-&gt;Host): The last packet from requested transfer has been transfered over USB bus and acknowledged </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9f0b03e5a41539896e07ccba22b67b3da76a716e60a05c83622c79910a404fd92"></a>NRF_DRV_USBD_EVT_CNT</em>&nbsp;</td><td class="fielddoc">
<p>Number of defined events </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacfe244baf5655539aa3e356620f2acfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbdraw__drv.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for the current transfer. </p>
<p>Flags configured for the transfer that can be merged using the bitwise 'or' operator (|). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3"></a>NRF_DRV_USBD_TRANSFER_ZLP_FLAG</em>&nbsp;</td><td class="fielddoc">
<p>Add a zero-length packet. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaad4f73e18396c94c6c6a90114ad3de6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the USBD port. </p>
<p>After calling this function USBD peripheral would be disabled. No events would be detected or processed by the library. Clock for the peripheral would be disconnected. </p>

</div>
</div>
<a class="anchor" id="gafee8557590430bd5d50d64b9363ecc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the USBD port. </p>
<p>After calling this function USBD peripheral would be enabled. It means that High Frequency clock would be requested and USB LDO would be enabled.</p>
<p>In normal situation this function should be called in reaction to USBDETECTED event from POWER peripheral.</p>
<p>Interrupts and USB pins pull-up would stay disabled until <a class="el" href="group__nrf__usbdraw__drv.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a> function is called. </p>

</div>
</div>
<a class="anchor" id="gacedb19d74504654d1628e0e3ca4976ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable selected endpoint. </p>
<p>This function disables endpoint itself and its interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4dd2c52f807f3663cc864f358fd53ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable selected endpoint. </p>
<p>This function enables endpoint itself and its interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to enable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Max packet size is set to endpoint default maximum value.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbdraw__drv.html#ga2cea23d18bfb29af3b36aa53b32fca14" title="Configure packet size that should be supported by the endpoint.">nrf_drv_usbd_ep_max_packet_size_set</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacd74bb1091ba7fb9a710ef98caf04df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_enable_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the selected endpoint is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Endpoint is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>Endpoint is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1219e767791807d91d92871e95346f91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_handled_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start sending data over the endpoint using the transfer handler function. </p>
<p>This function initializes an endpoint transmission. Just before data is transmitted, the transfer handler is called and it prepares a data chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. For an IN endpoint, sending is initiated. For an OUT endpoint, receiving is initiated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p_handler</td><td>Transfer handler - feeder for IN direction and consumer for OUT direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Selected endpoint is pending. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>Unexpected transfer on EPIN0 or EPOUT0. </td></tr>
    <tr><td class="paramname">NRF_ERROR_FORBIDDEN</td><td>Endpoint stalled. </td></tr>
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer queued or started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73852623b474a7626496366089cb1d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_is_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if endpoint buffer is ready or is under USB IP control. </p>
<p>Function to test if endpoint is busy. Endpoint that is busy cannot be accessed by MCU. It means that:</p>
<ul>
<li>OUT (TX) endpoint: Last uploaded data is still in endpoint and is waiting to be received by the host.</li>
<li>IN (RX) endpoint: Endpoint is ready to receive data from the host and the endpoint does not have any data. When endpoint is not busy:</li>
<li>OUT (TX) endpoint: New data can be uploaded.</li>
<li>IN (RX) endpoint: New data can be downloaded using <a class="el" href="group__nrf__usbdraw__drv.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> function. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga693c13c49ab1fbe7ffa42386de8a15af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nrf_drv_usbd_ep_max_packet_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configured endpoint packet size. </p>
<p>Function to get configured endpoint size on the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum pocket size configured on selected endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cea23d18bfb29af3b36aa53b32fca14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_max_packet_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure packet size that should be supported by the endpoint. </p>
<p>The real endpoint buffer size is always the same. This value sets max packet size that would be transmitted over the endpoint. This is required by the library</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Required maximum packet size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Endpoint size is always set to <a class="el" href="group__nrf__usbdraw__drv.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a> or <a class="el" href="group__nrf__usbdraw__drv.html#ga2482239c2133ddfe1fd269f8d2c44f6c">NRF_DRV_USBD_ISOSIZE</a> / 2 when <a class="el" href="group__nrf__usbdraw__drv.html#ga4dd2c52f807f3663cc864f358fd53ac6">nrf_drv_usbd_ep_enable</a> function is called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ca226d86703aad748af44ca24dd819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_stall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall endpoint. </p>
<p>Stall endpoit to send error information during next transfer request from the host.</p>
<dl class="section note"><dt>Note</dt><dd>To stall endpoint it is safer to use <a class="el" href="group__nrf__usbdraw__drv.html#ga680eae1b344512f9e7c166a740bfa5ba">nrf_drv_usbd_setup_stall</a> </dd>
<dd>
Stalled endpoint would not be cleared when DMA transfer finishes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to stall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca00e5defeb5986340ecd0e7e9c364b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_stall_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if endpoint is stalled. </p>
<p>This function gets stall state of selected endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58141094e1a11a5b0e91e4a3b0f02784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_stall_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear stall flag on endpoint. </p>
<p>This function clears endpoint that is stalled. </p>
<dl class="section note"><dt>Note</dt><dd>If it is OUT endpoint (receiving) it would be also prepared for reception. It means that busy flag would be set. </dd>
<dd>
In endpoint (transmitting) would not be cleared - it gives possibility to write new data before transmitting. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d3467a64cb0eba21868aa9a1e96f0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_status_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about last finished or current transfer. </p>
<p>Function returns the status of the last buffer set for transfer on selected endpoint. The status considers last buffer set by <a class="el" href="group__nrf__usbdraw__drv.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> function or by transfer callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_size</td><td>Information about the current/last transfer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer already finished </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Ongoing transfer </td></tr>
    <tr><td class="paramname">NRF_ERROR_DATA_SIZE</td><td>Too much of data received that cannot fit into buffer and cannot be splited into chunks. This may happen if buffer size is not a multiplication of endpoint buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfed547bace8fe28d0142ad1af18a008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start sending data over endpoint. </p>
<p>Function initializes endpoint transmission. This is asynchronous function - it finishes immediately after configuration for transmission is prepared.</p>
<dl class="section note"><dt>Note</dt><dd>Data buffer pointed by p_data have to be kept active till <a class="el" href="group__nrf__usbdraw__drv.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a> event is generated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. For IN endpoint sending would be initiated. For OUT endpoint receiving would be initiated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_transfer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Selected endpoint is pending. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>Unexpected transfer on EPIN0 or EPOUT0. </td></tr>
    <tr><td class="paramname">NRF_ERROR_FORBIDDEN</td><td>Endpoint stalled. </td></tr>
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer queued or started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada3a71a437745665c288110fdb0356b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nrf_drv_usbd_epout_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of received bytes. </p>
<p>Get the number of received bytes. The function behavior is undefined when called on IN endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes </dd></dl>

</div>
</div>
<a class="anchor" id="gad844c7b3654777b8e3a2c8d0b5657d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nrf_drv_usbd_feeder_buffer_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temporary buffer to be used by the feeder. </p>
<p>This buffer is used for TX transfers and it can be reused automatically when the transfer is finished. Use it for transfer preparation.</p>
<p>May be used inside the feeder configured in <a class="el" href="group__nrf__usbdraw__drv.html#ga1219e767791807d91d92871e95346f91">nrf_drv_usbd_ep_handled_transfer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the buffer that can be used temporarily.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbdraw__drv.html#gab4bbed2bd99a3c54cc5956f16b72061c" title="The size of internal feeder buffer.">NRF_DRV_USBD_FEEDER_BUFFER_SIZE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabf8b527764aefdbe4859981c56f96dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#ga5817eb96a762eea1263f4a39924ae411">nrf_drv_usbd_event_handler_t</a> const&#160;</td>
          <td class="paramname"><em>event_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>Event handler provided by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb2723c73382ccd1db168d6e79d53e47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is enabled. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is disabled </td></tr>
    <tr><td class="paramname">true</td><td>Driver is enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ecb8a9633445fd9e2eb79f956e69361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is initialized. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is not initialized </td></tr>
    <tr><td class="paramname">true</td><td>Driver is initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77db8d2bb83b5d393bd7b179f065fac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_started </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is started. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is not started </td></tr>
    <tr><td class="paramname">true</td><td>Driver is started (fully functional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The USBD peripheral interrupt state is checked </dd></dl>

</div>
</div>
<a class="anchor" id="ga569381189170f7bbce7995894bcfaa87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> nrf_drv_usbd_last_setup_dir_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about expected transfer SETUP data direction. </p>
<p>Function returns the information about last expected transfer direction.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_DRV_USBD_EPOUT0</td><td>Expecting OUT (Host-&gt;Device) direction or no data </td></tr>
    <tr><td class="paramname">NRF_DRV_USBD_EPIN0</td><td>Expecting IN (Device-&gt;Host) direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa8aa78cfbacee0edfc5f43d184aaaddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear setup endpoint. </p>
<p>This function acknowledges setup when SETUP command was received and processed. It has to be called if no data respond for the SETUP command is sent.</p>
<p>When there is any data transmission after SETUP command the data transmission itself would clear the endpoint. </p>

</div>
</div>
<a class="anchor" id="gac6a84106ecef4effd20d615fb985ecb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_data_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear only for data transmission on setup endpoint. </p>
<p>This function may be called if any more data in control write transfer is expected. Clears only OUT endpoint to be able to take another OUT data token. It does not allow STATUS stage. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbdraw__drv.html#gaa8aa78cfbacee0edfc5f43d184aaaddc" title="Clear setup endpoint.">nrf_drv_usbd_setup_clear</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae47e5d114e751ae88feee568a7dda845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a> *const&#160;</td>
          <td class="paramname"><em>p_setup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get parsed setup data. </p>
<p>Function fills the parsed setup data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_setup</td><td>Pointer to data structure that would be filled by parsed data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga680eae1b344512f9e7c166a740bfa5ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_stall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall setup endpoint. </p>
<p>Mark and error on setup endpoint. </p>

</div>
</div>
<a class="anchor" id="gacb757b8af8c827b45e306cfbd2d38045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_start </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_sof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start USB functionality. </p>
<p>After calling this function USBD peripheral should be fully functional and all new incoming events / interrupts would be processed by the library.</p>
<p>Also only after calling this function host sees new connected device.</p>
<p>Call this function when USBD power LDO regulator is ready - on USBPWRRDY event from POWER peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_sof</td><td>The flag that is used to enable SOF processing. If it is false, SOF interrupt is left disabled and will not be generated. This improves power saving if SOF is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the isochronous endpoints are going to be used, it is required to enable the SOF. In other case any isochronous endpoint would stay busy after first transmission. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ad60ee9a55f2be757f63b83ec7e45ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop USB functionality. </p>
<p>This function disables USBD pull-up and interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used to logically disconnect USB from the HOST that would force it to enumerate device after calling <a class="el" href="group__nrf__usbdraw__drv.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52acb0c56ab24137f5e6d45f47e46a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_transfer_out_drop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop transfer on OUT endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>OUT endpoint ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada87d3dd94488b499ce4b1d3f99b486d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbd_drv_ep_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__usbdraw__drv.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function locks interrupts that may be costly. It is good idea to test if the endpoint is still busy before calling this function: <div class="fragment"><div class="line">(m_ep_dma_waiting &amp; (1U &lt;&lt; ep2bit(ep)))</div>
</div><!-- fragment --> This function would check it again, but it makes it inside critical section. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri Mar 10 2017" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
